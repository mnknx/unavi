// @generated by protobuf-ts 2.9.1
// @generated from protobuf file "editor/edit.proto" (package "xyz.unavi.editor.edit", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * @generated from protobuf message xyz.unavi.editor.edit.EditNode
 */
export interface EditNode {
    /**
     * @generated from protobuf field: string target = 1;
     */
    target: string;
    /**
     * @generated from protobuf field: optional string name = 2;
     */
    name?: string;
    /**
     * @generated from protobuf field: optional string parent = 3;
     */
    parent?: string;
    /**
     * @generated from protobuf field: repeated float translation = 4;
     */
    translation: number[];
    /**
     * @generated from protobuf field: repeated float rotation = 5;
     */
    rotation: number[];
    /**
     * @generated from protobuf field: repeated float scale = 6;
     */
    scale: number[];
    /**
     * @generated from protobuf field: optional string mesh = 7;
     */
    mesh?: string;
    /**
     * @generated from protobuf field: optional xyz.unavi.editor.edit.EditNode.Extras extras = 8;
     */
    extras?: EditNode_Extras;
    /**
     * @generated from protobuf field: optional xyz.unavi.editor.edit.EditNode.Collider collider = 9;
     */
    collider?: EditNode_Collider;
    /**
     * @generated from protobuf field: optional xyz.unavi.editor.edit.EditNode.RigidBody rigid_body = 10;
     */
    rigidBody?: EditNode_RigidBody;
}
/**
 * @generated from protobuf message xyz.unavi.editor.edit.EditNode.Extras
 */
export interface EditNode_Extras {
    /**
     * @generated from protobuf field: bool locked = 1;
     */
    locked: boolean;
}
/**
 * @generated from protobuf message xyz.unavi.editor.edit.EditNode.Collider
 */
export interface EditNode_Collider {
    /**
     * @generated from protobuf field: xyz.unavi.editor.edit.EditNode.Collider.Type type = 1;
     */
    type: EditNode_Collider_Type;
    /**
     * @generated from protobuf field: optional float height = 2;
     */
    height?: number;
    /**
     * @generated from protobuf field: optional float radius = 3;
     */
    radius?: number;
    /**
     * @generated from protobuf field: repeated float size = 4;
     */
    size: number[];
    /**
     * @generated from protobuf field: optional string mesh = 5;
     */
    mesh?: string;
}
/**
 * @generated from protobuf enum xyz.unavi.editor.edit.EditNode.Collider.Type
 */
export enum EditNode_Collider_Type {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: BOX = 1;
     */
    BOX = 1,
    /**
     * @generated from protobuf enum value: SPHERE = 2;
     */
    SPHERE = 2,
    /**
     * @generated from protobuf enum value: CAPSULE = 3;
     */
    CAPSULE = 3,
    /**
     * @generated from protobuf enum value: CYLINDER = 4;
     */
    CYLINDER = 4,
    /**
     * @generated from protobuf enum value: MESH = 5;
     */
    MESH = 5,
    /**
     * @generated from protobuf enum value: HULL = 6;
     */
    HULL = 6
}
/**
 * @generated from protobuf message xyz.unavi.editor.edit.EditNode.RigidBody
 */
export interface EditNode_RigidBody {
    /**
     * @generated from protobuf field: xyz.unavi.editor.edit.EditNode.RigidBody.Type type = 1;
     */
    type: EditNode_RigidBody_Type;
    /**
     * @generated from protobuf field: optional float mass = 2;
     */
    mass?: number;
    /**
     * @generated from protobuf field: repeated float linear_velocity = 3;
     */
    linearVelocity: number[];
    /**
     * @generated from protobuf field: repeated float angular_velocity = 4;
     */
    angularVelocity: number[];
    /**
     * @generated from protobuf field: repeated float center_of_mass = 5;
     */
    centerOfMass: number[];
    /**
     * @generated from protobuf field: repeated float inertiaTensor = 6;
     */
    inertiaTensor: number[];
}
/**
 * @generated from protobuf enum xyz.unavi.editor.edit.EditNode.RigidBody.Type
 */
export enum EditNode_RigidBody_Type {
    /**
     * @generated from protobuf enum value: NONE = 0;
     */
    NONE = 0,
    /**
     * @generated from protobuf enum value: STATIC = 1;
     */
    STATIC = 1,
    /**
     * @generated from protobuf enum value: KINEMATIC = 2;
     */
    KINEMATIC = 2,
    /**
     * @generated from protobuf enum value: CHARACTER = 3;
     */
    CHARACTER = 3,
    /**
     * @generated from protobuf enum value: DYNAMIC = 4;
     */
    DYNAMIC = 4,
    /**
     * @generated from protobuf enum value: VEHICLE = 5;
     */
    VEHICLE = 5,
    /**
     * @generated from protobuf enum value: TRIGGER = 6;
     */
    TRIGGER = 6
}
/**
 * @generated from protobuf message xyz.unavi.editor.edit.EditMesh
 */
export interface EditMesh {
    /**
     * @generated from protobuf field: string target = 1;
     */
    target: string;
    /**
     * @generated from protobuf field: optional string name = 2;
     */
    name?: string;
    /**
     * @generated from protobuf field: optional string material = 3;
     */
    material?: string;
    /**
     * @generated from protobuf field: repeated uint32 indices = 4;
     */
    indices: number[];
    /**
     * @generated from protobuf field: repeated float position = 5;
     */
    position: number[];
    /**
     * @generated from protobuf field: repeated float normal = 6;
     */
    normal: number[];
    /**
     * @generated from protobuf field: repeated float color = 7;
     */
    color: number[];
    /**
     * @generated from protobuf field: repeated float weights = 8;
     */
    weights: number[];
    /**
     * @generated from protobuf field: repeated float joints = 9;
     */
    joints: number[];
    /**
     * @generated from protobuf field: repeated float uv = 10;
     */
    uv: number[];
    /**
     * @generated from protobuf field: repeated float uv1 = 11;
     */
    uv1: number[];
    /**
     * @generated from protobuf field: repeated float uv2 = 12;
     */
    uv2: number[];
    /**
     * @generated from protobuf field: repeated float uv3 = 13;
     */
    uv3: number[];
}
// @generated message type with reflection information, may provide speed optimized methods
class EditNode$Type extends MessageType<EditNode> {
    constructor() {
        super("xyz.unavi.editor.edit.EditNode", [
            { no: 1, name: "target", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "parent", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "translation", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 2 /*ScalarType.FLOAT*/ },
            { no: 5, name: "rotation", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 2 /*ScalarType.FLOAT*/ },
            { no: 6, name: "scale", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 2 /*ScalarType.FLOAT*/ },
            { no: 7, name: "mesh", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "extras", kind: "message", T: () => EditNode_Extras },
            { no: 9, name: "collider", kind: "message", T: () => EditNode_Collider },
            { no: 10, name: "rigid_body", kind: "message", T: () => EditNode_RigidBody }
        ]);
    }
    create(value?: PartialMessage<EditNode>): EditNode {
        const message = { target: "", translation: [], rotation: [], scale: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EditNode>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EditNode): EditNode {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string target */ 1:
                    message.target = reader.string();
                    break;
                case /* optional string name */ 2:
                    message.name = reader.string();
                    break;
                case /* optional string parent */ 3:
                    message.parent = reader.string();
                    break;
                case /* repeated float translation */ 4:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.translation.push(reader.float());
                    else
                        message.translation.push(reader.float());
                    break;
                case /* repeated float rotation */ 5:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.rotation.push(reader.float());
                    else
                        message.rotation.push(reader.float());
                    break;
                case /* repeated float scale */ 6:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.scale.push(reader.float());
                    else
                        message.scale.push(reader.float());
                    break;
                case /* optional string mesh */ 7:
                    message.mesh = reader.string();
                    break;
                case /* optional xyz.unavi.editor.edit.EditNode.Extras extras */ 8:
                    message.extras = EditNode_Extras.internalBinaryRead(reader, reader.uint32(), options, message.extras);
                    break;
                case /* optional xyz.unavi.editor.edit.EditNode.Collider collider */ 9:
                    message.collider = EditNode_Collider.internalBinaryRead(reader, reader.uint32(), options, message.collider);
                    break;
                case /* optional xyz.unavi.editor.edit.EditNode.RigidBody rigid_body */ 10:
                    message.rigidBody = EditNode_RigidBody.internalBinaryRead(reader, reader.uint32(), options, message.rigidBody);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EditNode, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string target = 1; */
        if (message.target !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.target);
        /* optional string name = 2; */
        if (message.name !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* optional string parent = 3; */
        if (message.parent !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.parent);
        /* repeated float translation = 4; */
        if (message.translation.length) {
            writer.tag(4, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.translation.length; i++)
                writer.float(message.translation[i]);
            writer.join();
        }
        /* repeated float rotation = 5; */
        if (message.rotation.length) {
            writer.tag(5, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.rotation.length; i++)
                writer.float(message.rotation[i]);
            writer.join();
        }
        /* repeated float scale = 6; */
        if (message.scale.length) {
            writer.tag(6, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.scale.length; i++)
                writer.float(message.scale[i]);
            writer.join();
        }
        /* optional string mesh = 7; */
        if (message.mesh !== undefined)
            writer.tag(7, WireType.LengthDelimited).string(message.mesh);
        /* optional xyz.unavi.editor.edit.EditNode.Extras extras = 8; */
        if (message.extras)
            EditNode_Extras.internalBinaryWrite(message.extras, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* optional xyz.unavi.editor.edit.EditNode.Collider collider = 9; */
        if (message.collider)
            EditNode_Collider.internalBinaryWrite(message.collider, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* optional xyz.unavi.editor.edit.EditNode.RigidBody rigid_body = 10; */
        if (message.rigidBody)
            EditNode_RigidBody.internalBinaryWrite(message.rigidBody, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message xyz.unavi.editor.edit.EditNode
 */
export const EditNode = new EditNode$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EditNode_Extras$Type extends MessageType<EditNode_Extras> {
    constructor() {
        super("xyz.unavi.editor.edit.EditNode.Extras", [
            { no: 1, name: "locked", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<EditNode_Extras>): EditNode_Extras {
        const message = { locked: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EditNode_Extras>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EditNode_Extras): EditNode_Extras {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool locked */ 1:
                    message.locked = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EditNode_Extras, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool locked = 1; */
        if (message.locked !== false)
            writer.tag(1, WireType.Varint).bool(message.locked);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message xyz.unavi.editor.edit.EditNode.Extras
 */
export const EditNode_Extras = new EditNode_Extras$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EditNode_Collider$Type extends MessageType<EditNode_Collider> {
    constructor() {
        super("xyz.unavi.editor.edit.EditNode.Collider", [
            { no: 1, name: "type", kind: "enum", T: () => ["xyz.unavi.editor.edit.EditNode.Collider.Type", EditNode_Collider_Type] },
            { no: 2, name: "height", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 3, name: "radius", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 4, name: "size", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 2 /*ScalarType.FLOAT*/ },
            { no: 5, name: "mesh", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<EditNode_Collider>): EditNode_Collider {
        const message = { type: 0, size: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EditNode_Collider>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EditNode_Collider): EditNode_Collider {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* xyz.unavi.editor.edit.EditNode.Collider.Type type */ 1:
                    message.type = reader.int32();
                    break;
                case /* optional float height */ 2:
                    message.height = reader.float();
                    break;
                case /* optional float radius */ 3:
                    message.radius = reader.float();
                    break;
                case /* repeated float size */ 4:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.size.push(reader.float());
                    else
                        message.size.push(reader.float());
                    break;
                case /* optional string mesh */ 5:
                    message.mesh = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EditNode_Collider, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* xyz.unavi.editor.edit.EditNode.Collider.Type type = 1; */
        if (message.type !== 0)
            writer.tag(1, WireType.Varint).int32(message.type);
        /* optional float height = 2; */
        if (message.height !== undefined)
            writer.tag(2, WireType.Bit32).float(message.height);
        /* optional float radius = 3; */
        if (message.radius !== undefined)
            writer.tag(3, WireType.Bit32).float(message.radius);
        /* repeated float size = 4; */
        if (message.size.length) {
            writer.tag(4, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.size.length; i++)
                writer.float(message.size[i]);
            writer.join();
        }
        /* optional string mesh = 5; */
        if (message.mesh !== undefined)
            writer.tag(5, WireType.LengthDelimited).string(message.mesh);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message xyz.unavi.editor.edit.EditNode.Collider
 */
export const EditNode_Collider = new EditNode_Collider$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EditNode_RigidBody$Type extends MessageType<EditNode_RigidBody> {
    constructor() {
        super("xyz.unavi.editor.edit.EditNode.RigidBody", [
            { no: 1, name: "type", kind: "enum", T: () => ["xyz.unavi.editor.edit.EditNode.RigidBody.Type", EditNode_RigidBody_Type] },
            { no: 2, name: "mass", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 3, name: "linear_velocity", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 2 /*ScalarType.FLOAT*/ },
            { no: 4, name: "angular_velocity", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 2 /*ScalarType.FLOAT*/ },
            { no: 5, name: "center_of_mass", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 2 /*ScalarType.FLOAT*/ },
            { no: 6, name: "inertiaTensor", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<EditNode_RigidBody>): EditNode_RigidBody {
        const message = { type: 0, linearVelocity: [], angularVelocity: [], centerOfMass: [], inertiaTensor: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EditNode_RigidBody>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EditNode_RigidBody): EditNode_RigidBody {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* xyz.unavi.editor.edit.EditNode.RigidBody.Type type */ 1:
                    message.type = reader.int32();
                    break;
                case /* optional float mass */ 2:
                    message.mass = reader.float();
                    break;
                case /* repeated float linear_velocity */ 3:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.linearVelocity.push(reader.float());
                    else
                        message.linearVelocity.push(reader.float());
                    break;
                case /* repeated float angular_velocity */ 4:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.angularVelocity.push(reader.float());
                    else
                        message.angularVelocity.push(reader.float());
                    break;
                case /* repeated float center_of_mass */ 5:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.centerOfMass.push(reader.float());
                    else
                        message.centerOfMass.push(reader.float());
                    break;
                case /* repeated float inertiaTensor */ 6:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.inertiaTensor.push(reader.float());
                    else
                        message.inertiaTensor.push(reader.float());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EditNode_RigidBody, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* xyz.unavi.editor.edit.EditNode.RigidBody.Type type = 1; */
        if (message.type !== 0)
            writer.tag(1, WireType.Varint).int32(message.type);
        /* optional float mass = 2; */
        if (message.mass !== undefined)
            writer.tag(2, WireType.Bit32).float(message.mass);
        /* repeated float linear_velocity = 3; */
        if (message.linearVelocity.length) {
            writer.tag(3, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.linearVelocity.length; i++)
                writer.float(message.linearVelocity[i]);
            writer.join();
        }
        /* repeated float angular_velocity = 4; */
        if (message.angularVelocity.length) {
            writer.tag(4, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.angularVelocity.length; i++)
                writer.float(message.angularVelocity[i]);
            writer.join();
        }
        /* repeated float center_of_mass = 5; */
        if (message.centerOfMass.length) {
            writer.tag(5, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.centerOfMass.length; i++)
                writer.float(message.centerOfMass[i]);
            writer.join();
        }
        /* repeated float inertiaTensor = 6; */
        if (message.inertiaTensor.length) {
            writer.tag(6, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.inertiaTensor.length; i++)
                writer.float(message.inertiaTensor[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message xyz.unavi.editor.edit.EditNode.RigidBody
 */
export const EditNode_RigidBody = new EditNode_RigidBody$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EditMesh$Type extends MessageType<EditMesh> {
    constructor() {
        super("xyz.unavi.editor.edit.EditMesh", [
            { no: 1, name: "target", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "material", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "indices", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "position", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 2 /*ScalarType.FLOAT*/ },
            { no: 6, name: "normal", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 2 /*ScalarType.FLOAT*/ },
            { no: 7, name: "color", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 2 /*ScalarType.FLOAT*/ },
            { no: 8, name: "weights", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 2 /*ScalarType.FLOAT*/ },
            { no: 9, name: "joints", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 2 /*ScalarType.FLOAT*/ },
            { no: 10, name: "uv", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 2 /*ScalarType.FLOAT*/ },
            { no: 11, name: "uv1", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 2 /*ScalarType.FLOAT*/ },
            { no: 12, name: "uv2", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 2 /*ScalarType.FLOAT*/ },
            { no: 13, name: "uv3", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<EditMesh>): EditMesh {
        const message = { target: "", indices: [], position: [], normal: [], color: [], weights: [], joints: [], uv: [], uv1: [], uv2: [], uv3: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EditMesh>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EditMesh): EditMesh {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string target */ 1:
                    message.target = reader.string();
                    break;
                case /* optional string name */ 2:
                    message.name = reader.string();
                    break;
                case /* optional string material */ 3:
                    message.material = reader.string();
                    break;
                case /* repeated uint32 indices */ 4:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.indices.push(reader.uint32());
                    else
                        message.indices.push(reader.uint32());
                    break;
                case /* repeated float position */ 5:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.position.push(reader.float());
                    else
                        message.position.push(reader.float());
                    break;
                case /* repeated float normal */ 6:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.normal.push(reader.float());
                    else
                        message.normal.push(reader.float());
                    break;
                case /* repeated float color */ 7:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.color.push(reader.float());
                    else
                        message.color.push(reader.float());
                    break;
                case /* repeated float weights */ 8:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.weights.push(reader.float());
                    else
                        message.weights.push(reader.float());
                    break;
                case /* repeated float joints */ 9:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.joints.push(reader.float());
                    else
                        message.joints.push(reader.float());
                    break;
                case /* repeated float uv */ 10:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.uv.push(reader.float());
                    else
                        message.uv.push(reader.float());
                    break;
                case /* repeated float uv1 */ 11:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.uv1.push(reader.float());
                    else
                        message.uv1.push(reader.float());
                    break;
                case /* repeated float uv2 */ 12:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.uv2.push(reader.float());
                    else
                        message.uv2.push(reader.float());
                    break;
                case /* repeated float uv3 */ 13:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.uv3.push(reader.float());
                    else
                        message.uv3.push(reader.float());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EditMesh, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string target = 1; */
        if (message.target !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.target);
        /* optional string name = 2; */
        if (message.name !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* optional string material = 3; */
        if (message.material !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.material);
        /* repeated uint32 indices = 4; */
        if (message.indices.length) {
            writer.tag(4, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.indices.length; i++)
                writer.uint32(message.indices[i]);
            writer.join();
        }
        /* repeated float position = 5; */
        if (message.position.length) {
            writer.tag(5, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.position.length; i++)
                writer.float(message.position[i]);
            writer.join();
        }
        /* repeated float normal = 6; */
        if (message.normal.length) {
            writer.tag(6, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.normal.length; i++)
                writer.float(message.normal[i]);
            writer.join();
        }
        /* repeated float color = 7; */
        if (message.color.length) {
            writer.tag(7, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.color.length; i++)
                writer.float(message.color[i]);
            writer.join();
        }
        /* repeated float weights = 8; */
        if (message.weights.length) {
            writer.tag(8, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.weights.length; i++)
                writer.float(message.weights[i]);
            writer.join();
        }
        /* repeated float joints = 9; */
        if (message.joints.length) {
            writer.tag(9, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.joints.length; i++)
                writer.float(message.joints[i]);
            writer.join();
        }
        /* repeated float uv = 10; */
        if (message.uv.length) {
            writer.tag(10, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.uv.length; i++)
                writer.float(message.uv[i]);
            writer.join();
        }
        /* repeated float uv1 = 11; */
        if (message.uv1.length) {
            writer.tag(11, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.uv1.length; i++)
                writer.float(message.uv1[i]);
            writer.join();
        }
        /* repeated float uv2 = 12; */
        if (message.uv2.length) {
            writer.tag(12, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.uv2.length; i++)
                writer.float(message.uv2[i]);
            writer.join();
        }
        /* repeated float uv3 = 13; */
        if (message.uv3.length) {
            writer.tag(13, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.uv3.length; i++)
                writer.float(message.uv3[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message xyz.unavi.editor.edit.EditMesh
 */
export const EditMesh = new EditMesh$Type();
